addpath(genpath('../common'))
% Just for fun... an array of pretty trajectories generated by the minimal
% model

% Define parameters.
params = struct();
A_1 = 1; params.A_1 = A_1; % base amplitude of first flagellum
A_2 = 1.1; params.A_2 = A_2;% differential amplitude of second flagellum
eta_t = 1/A_1; params.eta_t = eta_t;% translation coefficient
eta_r = 1/A_1; params.eta_r = eta_r;% rotatoon coefficient
k_1 = 1; params.k_1 = k_1; % frequency of first flagellum
k_2 = 1.6; params.k_2 = k_2; % frequency of second flagellum

f_0_var = 1*[0.125, 0.25, 0.375, 0.625,...
           0.75, 15/16, 6/7, 3/7,...
           9/11, 0.6, 0.8, 0.9];

T_var = 20*[50, 500, 50, 150,...
         50, 50, 50, 50,...
         100, 50, 50, 50];

all_tps = cell(1,length(f_0_var));
all_x = cell(1,length(f_0_var));
all_y = cell(1,length(f_0_var));
all_th = cell(1,length(f_0_var));

for i = 1:length(f_0_var)
f = @(t) f_0_var(i)+1*sin(0.25*t); params.f = f;% periodic activation function

% ODE conditions setup.
init = [0;0;0];
T = T_var(i); nb_dt = 6e3;
tps = linspace(0,T,nb_dt);

% ODE solver setup.
opts = odeset('RelTol',1e-10,'AbsTol',1e-10);
dZ= @(t,z) dynamics(t,z,params);

% Solving the dynamics.
[tps, traj] = ode45(dZ,tps,init,opts);

all_tps = tps;
all_x{1,i} = traj(:,1);
all_y{1,i} = traj(:,2);
all_th{1,i} = traj(:,3);

end

% Plot
figure(1);clf;
set(gcf,'color','w');
tiledlayout(3,4)

col = colormap(othercolor('Paired10',length(f_0_var)));

for i = 1:length(f_0_var)
    nexttile(i);
    plot(all_x{i},all_y{i},'Color',col(i,:),'LineWidth',1.5)
    axis equal tight off
end

exportgraphics(gcf,'pretty.pdf','ContentType','vector')

function zdot = dynamics(t,z,params)

    % Unpack parameters.
    eta_t = params.eta_t;
    eta_r = params.eta_r;
    A_1 = params.A_1;
    A_2 = params.A_2;
    f = params.f;
    k_1 = params.k_1;
    k_2 = params.k_2;

    % Unpack state.
    x = z(1);
    y = z(2);
    theta = z(3);

    % Define velocity.
    V = eta_t * (A_1 * k_1 * f(k_1*t) + A_2 * k_2 * f(k_2*t));

    % Compute the dynamics.
    zdot = zeros(3,1);
    zdot(1) = V*cos(theta);
    zdot(2) = V*sin(theta);
    zdot(3) = eta_r * (A_1 * k_1 * f(k_1*t) - A_2 * k_2 * f(k_2*t));
end


